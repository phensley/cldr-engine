<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Resource bundles · @phensley/cldr</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="This document goes into detail on the rationale for the design of the [resource bundle file format](https://unpkg.com/@phensley/cldr@0.6.3/packs/) and how field values are encoded and later retrieved at runtime."/><meta name="docsearch:version" content="1.1.2"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Resource bundles · @phensley/cldr"/><meta property="og:type" content="website"/><meta property="og:url" content="https://phensley.github.io/cldr-engine/"/><meta property="og:description" content="This document goes into detail on the rationale for the design of the [resource bundle file format](https://unpkg.com/@phensley/cldr@0.6.3/packs/) and how field values are encoded and later retrieved at runtime."/><meta property="og:image" content="https://phensley.github.io/cldr-engine/img/cldr-engine-logo-bw.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://phensley.github.io/cldr-engine/img/cldr-engine-logo-bw.png"/><link rel="shortcut icon" href="/cldr-engine/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-121435304-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,300italic"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/cldr-engine/js/sidenav.js"></script><script src="/cldr-engine/js/scrollSpy.js"></script><link rel="stylesheet" href="/cldr-engine/css/main.css"/><script src="/cldr-engine/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/cldr-engine/en"><img class="logo" src="/cldr-engine/img/cldr-engine-logo-w.svg" alt="@phensley/cldr"/><h2 class="headerTitleWithLogo">@phensley/cldr</h2></a><a href="/cldr-engine/en/versions"><h3>1.1.2</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/cldr-engine/docs/en/1.1.2/doc-index" target="_self">Docs</a></li><li class=""><a href="/cldr-engine/docs/en/1.1.2/api-cldr" target="_self">API</a></li><li class=""><a href="https://phensley.github.io/cldr-engine-react-demo" target="_self">Demo </a></li><li class=""><a href="https://github.com/phensley/cldr-engine" target="_self">Github</a></li><li class=""><a href="https://yarnpkg.com/package/@phensley/cldr" target="_self">Yarn</a></li><li class=""><a href="https://www.npmjs.com/package/@phensley/cldr" target="_self">NPM</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Design</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-index">Overview</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-goals">Goals</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-faq">Rationale</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-quickstart">Quick start</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Locales</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-locales-parsing">Locale parsing</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-locales-resolution">Locale resolution</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-locales-matching">Language matching</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Calendars</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-calendar-overview">Calendar Overview</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-calendar-examples">Example: date formatting</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Math</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-math">Arbitrary Precision</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-math-example-factorial">Example: factorial</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-math-example-rational-approx">Math: rational approximation</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-math-example-contd-fractions">Math: continued fractions</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Message Formatting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-messageformatting">Usage</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-messageformatting-custom">Customization</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Design</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-design-bundles">Resource bundles</a></li><li class="navListItem"><a class="navItem" href="/cldr-engine/docs/en/1.1.2/doc-design-caching">Caching</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Resource bundles</h1></header><article><div><span><p>This document goes into detail on the rationale for the design of the <a href="https://unpkg.com/@phensley/cldr@0.6.3/packs/">resource bundle file format</a> and how field values are encoded and later retrieved at runtime.</p>
<p>Resource bundles / packs contain the locale-specific strings that will be used by the framework for various purposes. These include calendar and number formatting patterns, names of the months and weekdays, names of units of measure, and so on.</p>
<p>When an application changes locale in response to a user action, the bundle for that locale needs to be loaded as quickly as possible. The resource bundles should be as small as possible, so they can be transferred over the network quickly, and once instantiated use as little of JavaScript heap as possible.</p>
<p>The first section discusses some limitations around using the CLDR JSON data directly. The second section discusses the approach used to design this library's resource bundle encoding, and the ways it is accessed internally.</p>
<h2><a class="anchor" aria-hidden="true" id="cldr-json-data"></a><a href="#cldr-json-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CLDR JSON data</h2>
<p>Below we discuss some of the limitations of using the <a href="https://github.com/unicode-cldr">JSON encoding of the CLDR data</a> directly at runtime.</p>
<h3><a class="anchor" aria-hidden="true" id="data-size"></a><a href="#data-size" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Data size</h3>
<p>The CLDR JSON data set is quite large. The design goals for this library require that we have a lot of CLDR data available at runtime, so the size of the data is a major concern.</p>
<p>CLDR data is split across several files. For example, &quot;ca-gregorian.json&quot; contains fields relating to the Gregorian calendar. The size of the data set depends on which files your library requires. At the time of this writing, this library uses data contained in the following 16 JSON files across all 360 modern locales (where present):</p>
<pre><code class="hljs css language-typescript">[
  <span class="hljs-string">'ca-buddhist'</span>, <span class="hljs-string">'ca-gregorian'</span>, <span class="hljs-string">'ca-japanese'</span>, <span class="hljs-string">'ca-persian'</span>, <span class="hljs-string">'characters'</span>,
  <span class="hljs-string">'contextTransforms'</span>, <span class="hljs-string">'currencies'</span>, <span class="hljs-string">'dateFields'</span>, <span class="hljs-string">'languages'</span>, <span class="hljs-string">'layout'</span>,
  <span class="hljs-string">'listPatterns'</span>, <span class="hljs-string">'numbers'</span>, <span class="hljs-string">'scripts'</span>, <span class="hljs-string">'territories'</span>, <span class="hljs-string">'timeZoneNames'</span>,
  <span class="hljs-string">'units'</span>
]
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="schema-overhead"></a><a href="#schema-overhead" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schema overhead</h3>
<p>The JSON encoding stores values in a hierarchical schema. Finding a value requires traversing a path in the tree until we reach a leaf node that holds the value.</p>
<p>The intermediate nodes in the tree add considerable overhead to the JSON encoding. For example, if you want to find the &quot;full date format for the Gregorian calendar&quot; in the &quot;en-001/ca-gregorian.json&quot; file, you would traverse the following path:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-string">"main"</span>: {
  <span class="hljs-string">"en-001"</span>: {
    <span class="hljs-string">"dates"</span>: {
      <span class="hljs-string">"calendars"</span>: {
        <span class="hljs-string">"gregorian"</span>: {
          <span class="hljs-string">"dateFormats"</span>: {
            <span class="hljs-string">"full"</span>: <span class="hljs-string">"EEEE, d MMMM y"</span> <span class="hljs-comment">// leaf</span>

<span class="hljs-comment">// We traverse 77 bytes of schema ...</span>
<span class="hljs-string">"main"</span>:{<span class="hljs-string">"en-001"</span>:{<span class="hljs-string">"dates"</span>:{<span class="hljs-string">"calendars"</span>:{<span class="hljs-string">"gregorian"</span>:{<span class="hljs-string">"dateFormats"</span>:{<span class="hljs-string">"full"</span>:

<span class="hljs-comment">// .. to access a 12 byte value</span>
<span class="hljs-string">"EEEE, d MMMM y"</span>
</code></pre>
<p>Admittedly some of this schema is reused across multiple fields, but it would be nice if we could eliminate it.</p>
<h4><a class="anchor" aria-hidden="true" id="storing-the-full-schema-vs-values-only"></a><a href="#storing-the-full-schema-vs-values-only" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Storing the full schema vs values only</h4>
<p>Below are the sizes for the JSON representation of these 16 files across all 360 locales.</p>
<table>
<thead>
<tr><th>size (MB)</th><th>object</th></tr>
</thead>
<tbody>
<tr><td>139</td><td>All locales, full schema</td></tr>
<tr><td>16</td><td>All locales, full schema, gzip</td></tr>
<tr><td>34</td><td>All locales, values only</td></tr>
<tr><td>7</td><td>All locales, values only, gzip</td></tr>
</tbody>
</table>
<p>Storing just the values reduces the size to 1/4 of the original. Even if we can eliminate the schema, 34 MB is still large.</p>
<p>This raises the question of how to eliminate the schema but still make the field data easily accessible.</p>
<h3><a class="anchor" aria-hidden="true" id="accessing-field-values-can-be-brittle"></a><a href="#accessing-field-values-can-be-brittle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing field values can be brittle</h3>
<p>If we were to use the JSON representation directly, the interface for retrieving a field would need to accept a path as an argument.  There are a few possible ways this interface could look:</p>
<p><strong>1. Path as template string</strong></p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> bundle = <span class="hljs-keyword">get</span>(<span class="hljs-string">'en-001'</span>);
<span class="hljs-keyword">const</span> width = <span class="hljs-string">'full'</span>;
<span class="hljs-keyword">const</span> path = <span class="hljs-string">`main/<span class="hljs-subst">${locale}</span>/dates/calendars/gregorian/dateFormats/<span class="hljs-subst">${width}</span>`</span>;
<span class="hljs-keyword">const</span> value = bundle.get(path);
</code></pre>
<p><strong>2. Path as array</strong></p>
<p>This is more efficient since it doesn't have to reconstruct the array by splitting the string, or implement some iterative traversal of the path.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> path = [<span class="hljs-string">'main'</span>, locale, <span class="hljs-string">'dates'</span>, <span class="hljs-string">'calendars'</span>, <span class="hljs-string">'gregorian'</span>, <span class="hljs-string">'dateFormats'</span>, width];
<span class="hljs-keyword">const</span> value = bundle.get(path);
</code></pre>
<p><strong>3. Direct access</strong></p>
<p>Parsing most of the files in JSON should result in a series of nested JavaScript objects, and many of the keys in the schema correspond to valid JavaScript identifiers, we can directly access nested objects</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> value = bundle.main[locale].dates.calendars.gregorian.dateFormats[width];
</code></pre>
<p>In all these variants, with path segments composed using strings or object properties, there is a chance of making mistakes. A developer would always need to get the naming correct, e.g. <code>&quot;dateFormats&quot;</code> not <code>&quot;dateformats&quot;</code>, and any mistakes would need to be caught at runtime with a unit test.</p>
<p>This reliance on high test coverage to catch path/property name errors isn't so bad, and a lot of JavaScript libraries are developed this way; however, since the CLDR schema is large and complex it would be much nicer if we had a typesafe interface to access the fields.</p>
<p><strong>Goal: typesafe accessor</strong></p>
<p>Our goal should be direct access but with compile-time checking against a schema, and ideally where that schema is a singleton object we can reuse across all bundles.</p>
<p>The type information provides some compile time validation of our field accesses, and drives the autocompletion features of IDEs, saving developers having to refer back to the JSON structure to construct paths.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">interface</span> DateFormats {
  <span class="hljs-keyword">get</span>(bundle: Bundle, width: FormatWidthType);
}

<span class="hljs-keyword">interface</span> GregorianSchema {
  dateFormats: DateFormats;
}

<span class="hljs-keyword">interface</span> CalendarSchema {
  gregorian: GregorianSchema;
}

<span class="hljs-keyword">interface</span> Schema {
  calendars: CalendarSchema;
}

<span class="hljs-keyword">const</span> bundle = <span class="hljs-keyword">get</span>(<span class="hljs-string">'en-001'</span>);
<span class="hljs-keyword">const</span> width = <span class="hljs-string">'medium'</span>;
<span class="hljs-keyword">const</span> value = schema.calendars.gregorian.dateFormats.get(bundle, width);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="questions-so-far"></a><a href="#questions-so-far" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Questions so far:</h3>
<ol>
<li>How do we eliminate the schema while still being able to access the field values?</li>
<li>Can we reduce a resource bundle's size further, beyond just eliminating the schema?</li>
<li>Can we define a bundle encoding that is simultaneously small, simple and fast?</li>
<li>Can we define a way of accessing fields in the schema that is typesafe and static?</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="designing-the-resource-bundle"></a><a href="#designing-the-resource-bundle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Designing the resource bundle</h2>
<p>The design of the <strong>phensley/cldr</strong> bundle format involves several choices, described below.</p>
<h3><a class="anchor" aria-hidden="true" id="1-flatten-the-schema"></a><a href="#1-flatten-the-schema" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. Flatten the schema</h3>
<p>The CLDR's JSON schema is quite deep, but we prefer something more compact. Performance should improve if we traverse fewer levels to get to a field value.</p>
<p>To achieve this we transform the schema on the fly using <a href="https://github.com/calmm-js/partial.lenses">lenses</a>, to flatten, filter, and transform the data tree.</p>
<p>Using the &quot;dateFormats&quot; example above, we remove several of the levels, flattening it to:</p>
<pre><code class="hljs css language-javascript">{
  <span class="hljs-string">"Gregorian"</span>: {
    <span class="hljs-string">"dateFormats"</span>: {
      <span class="hljs-string">"short"</span>: <span class="hljs-string">"dd/MM/y"</span>,
      <span class="hljs-string">"medium"</span>: <span class="hljs-string">"d MMM y"</span>,
      <span class="hljs-string">"long"</span>: <span class="hljs-string">"d MMMM y"</span>,
      <span class="hljs-string">"full"</span>: <span class="hljs-string">"EEEE, d MMMM y"</span>,
    <span class="hljs-string">"timeFormats"</span>: {
      <span class="hljs-string">"short"</span>: <span class="hljs-string">"h:mm a"</span>,
      <span class="hljs-string">"medium"</span>: <span class="hljs-string">"h:mm:ss a"</span>,
      <span class="hljs-string">"long"</span>: <span class="hljs-string">"h:mm:ss a z"</span>,
      <span class="hljs-string">"full"</span>: <span class="hljs-string">"h:mm:ss a zzzz"</span>
    },
  ...
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="2-define-an-ordered-traversal-of-all-fields-in-the-schema"></a><a href="#2-define-an-ordered-traversal-of-all-fields-in-the-schema" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Define an ordered traversal of all fields in the schema</h3>
<p>Given the flattened schema above, we want to define a (deterministic) ordered traversal of all fields for a locale.</p>
<p>For example, given the array <code>['short', 'medium', 'long', 'full']</code>, each time we iterate over it we always visit the elements in the same order. <strong>We extend this concept to the entire schema, as if it were part of one large array</strong>.</p>
<p>We express this using a DSL that can be written in Typescript. Here are a few of the types we need in our DSL:</p>
<ul>
<li><code class="def">keyindex(keys)</code>
<ul>
<li>Map an array element's offset to the element</li>
</ul></li>
<li><code class="def">scope(name, block)</code>
<ul>
<li>Creates a named scope that contains a nested array of nodes</li>
</ul></li>
<li><code class="def">vector1(name, index)</code>
<ul>
<li>A 1-dimensional vector with a name and a key index</li>
</ul></li>
</ul>
<p>Then we can express our schema's structure using the DSL:</p>
<pre><code class="hljs css language-typescript">formatWidths = keyindex([<span class="hljs-string">'short'</span>,<span class="hljs-string">'medium'</span>,<span class="hljs-string">'long'</span>,<span class="hljs-string">'full'</span>]);

scope(<span class="hljs-string">'Gregorian'</span>, [
  vector1(<span class="hljs-string">'dateFormats'</span>, formatWidths),
  vector1(<span class="hljs-string">'timeFormats'</span>, formatWidths),
]);
</code></pre>
<p>Other libraries require a developer to identify which parts of the CLDR JSON file(s) they need and filter the JSON files as part of their build process. Since the DSL only refers to fields that are used by the library, it performs this filtering process.</p>
<h3><a class="anchor" aria-hidden="true" id="3-use-the-dsl-program-to-both-encode-and-access-field-values"></a><a href="#3-use-the-dsl-program-to-both-encode-and-access-field-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. Use the DSL program to both encode and access field values</h3>
<p>Next we build 2 interpreters for the above DSL:</p>
<ul>
<li><code class="def">Encoder</code>
<ul>
<li>Executed at build time, it traverses the schema and encodes the fields into a resource bundle.</li>
</ul></li>
<li><code class="def">Accessor builder</code>
<ul>
<li>Executed once at runtime during library initialization, it builds an accessor object that can be used to fetch field values from a bundle.</li>
</ul></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="encoder"></a><a href="#encoder" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Encoder</h4>
<p>As we traverse the DSL and visit each field we increment an offset by 1. This offset is the position of that field's value in the final array.</p>
<p>Once the encoding is complete, we convert the array into a tab-separated string:</p>
<pre><code class="hljs css language-typescript">..
<span class="hljs-comment">// Gregorian {</span>
<span class="hljs-comment">//   dateFormats.{short, medium, long, full}</span>
<span class="hljs-comment">//     =&gt; offsets 0, 1, 2, 3</span>
[<span class="hljs-string">'dd/MM/y'</span>, <span class="hljs-string">'dd MMM y'</span>, <span class="hljs-string">'d MMMM y'</span>, <span class="hljs-string">'EEEE, d MMMM y'</span>,

<span class="hljs-comment">//   timeFormats.{short, medium, long, full}</span>
<span class="hljs-comment">//     =&gt; offsets 4, 5, 6, 7</span>
<span class="hljs-string">'h:mm a'</span>, <span class="hljs-string">'h:mm:ss a'</span>, <span class="hljs-string">'h:mm:ss a z'</span>, <span class="hljs-string">'h:mm:ss a zzzz'</span>]
.join(<span class="hljs-string">'\t'</span>)
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="accessor-builder"></a><a href="#accessor-builder" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessor builder</h4>
<p>The accessor builder constructs an object that mirrors our schema's structure, and our <code>vector1</code> type generates a function for fetching a specific field value.</p>
<p>Here is how we might use the accessor object for our DSL to fetch the &quot;medium time format&quot; value.</p>
<p>The <code>timeFormats</code> object is a 1-dimensional vector arrow whose base offset is 4. It uses the key index <code>['short', 'medium', 'long', 'full']</code>. Since the argument <code>'medium'</code> is at index 1, the desired pattern will be found in the string table at offset 5:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> pattern = schema.Gregorian.timeFormats.get(bundle, <span class="hljs-string">'medium'</span>);
<span class="hljs-built_in">console</span>.log(pattern);
</code></pre>
<pre class="output">
h:mm:ss a
</pre>
<h3><a class="anchor" aria-hidden="true" id="4-encode-all-locales-for-a-given-language-in-single-bundle"></a><a href="#4-encode-all-locales-for-a-given-language-in-single-bundle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4. Encode all locales for a given language in single bundle</h3>
<p>We put all of the regions and scripts for a given language together. So for Spanish, we would bundle together 'es', 'es-419', 'es-AR', 'es-BO', etc.</p>
<p>This has a few advantages:</p>
<ul>
<li class="list">A language's regions tend to be quite similar, so we can exploit this to reduce the duplication.</li>
<li class="list">In an application, a user might select their language and then separately select their country. Once the language is selected and that bundle loaded, no further network traffic is required when choosing a region.</li>
<li class="list">It results in fewer bundles, and simplifies resolving the bundle for a locale, since we only need to map the 2- or 3-character language code to a filename without dealing with its script and region subtags.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="5-define-a-base-region-in-the-bundle-per-script-from-which-all-other-regions-inherit"></a><a href="#5-define-a-base-region-in-the-bundle-per-script-from-which-all-other-regions-inherit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5. Define a base region in the bundle, per script, from which all other regions inherit</h3>
<p>Start by creating the full string array for all locales in a given language. We use letters of the alphabet as field values for clarity:</p>
<pre><code class="hljs css language-typescript">{
  <span class="hljs-string">'en-001'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>],
      <span class="hljs-string">'en'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>],
   <span class="hljs-string">'en-CA'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'f'</span>],
   ...
}
</code></pre>
<p>Next compute the pairwise distance between each array and the others, and choose the array with the lowest total distance. This will become the base region.</p>
<pre><code class="hljs css language-typescript">{
  <span class="hljs-string">'en-001'</span>: {     <span class="hljs-string">'en'</span>: <span class="hljs-number">1</span>,  <span class="hljs-string">'en-CA'</span>: <span class="hljs-number">2</span> },  <span class="hljs-comment">// dist 3, base region</span>
      <span class="hljs-string">'en'</span>: { <span class="hljs-string">'en-001'</span>: <span class="hljs-number">1</span>,  <span class="hljs-string">'en-CA'</span>: <span class="hljs-number">3</span> },  <span class="hljs-comment">// dist 4</span>
   <span class="hljs-string">'en-CA'</span>: {     <span class="hljs-string">'en'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'en-001'</span>: <span class="hljs-number">2</span> }   <span class="hljs-comment">// dist 5</span>
  }
}
</code></pre>
<p>To remove the duplicates we:</p>
<ul>
<li class="list">Encode the full string array for the base region</li>
<li class="list">Encode a delta index for each individual region.
<ul>
<li class="list">When we find a string that differs, we map the string's offset to a index in an &quot;exceptions&quot; array.</li>
</ul></li>
</ul>
<p>The resulting bundle will look something like this:</p>
<pre><code class="hljs css language-typescript">{
  <span class="hljs-string">"language"</span>: <span class="hljs-string">"en"</span>,
  <span class="hljs-string">"default"</span>: <span class="hljs-string">"en-Latn-US"</span>,
  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"Latn"</span>: {
      <span class="hljs-string">"base"</span>: <span class="hljs-string">'a b c d e f'</span>,
      <span class="hljs-string">"exceptions"</span>: <span class="hljs-string">'Q R S'</span>,
      <span class="hljs-string">"regions"</span>: {
        <span class="hljs-string">"001"</span>: <span class="hljs-string">""</span>,        <span class="hljs-comment">// en-001 == base region</span>
         <span class="hljs-string">"US"</span>: <span class="hljs-string">"2:0"</span>,     <span class="hljs-comment">// c -&gt; Q</span>
         <span class="hljs-string">"CA"</span>: <span class="hljs-string">"1:1 4:2"</span>  <span class="hljs-comment">// b -&gt; R, e -&gt; S</span>
      }
    }
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="resulting-size-of-the-phensleycldr-resource-bundles"></a><a href="#resulting-size-of-the-phensleycldr-resource-bundles" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resulting size of the @phensley/cldr resource bundles</h4>
<p>To summarize we have:</p>
<ul>
<li class="list">Flattened the schema</li>
<li class="list">Encoded the values only</li>
<li class="list">Encoded all scripts/regions of a language into a single resource bundle</li>
<li class="list">Reduced duplicates by regions inheriting from a base region</li>
<li class="list">All field lookups are fast since they're indexing into a string array.</li>
</ul>
<p>The resulting bundle sizes:</p>
<table>
<thead>
<tr><th>size</th><th>object</th></tr>
</thead>
<tbody>
<tr><td>11 MB</td><td>All resource bundles</td></tr>
<tr><td>1.5 MB</td><td>All .. with 'gzip --best'</td></tr>
<tr><td>192 KB</td><td>English resource bundle (104 locales)</td></tr>
<tr><td>34 KB</td><td>English .. with 'gzip --best'</td></tr>
</tbody>
</table>
<p>The bundle format can likely be further improved, but it is simple and the size is sufficient for the current version.</p>
<pre><code class="hljs css language-sh">$ du -sbh node_modules/@phensley/cldr/packs/en.json.gz
34K node_modules/@phensley/cldr/packs/en.json.gz

$ gunzip -c node_modules/@phensley/cldr/packs/en.json.gz | fold -w 80 | head -10
{<span class="hljs-string">"version"</span>:<span class="hljs-string">"0.6.3"</span>,<span class="hljs-string">"cldr"</span>:<span class="hljs-string">"32.0.1"</span>,<span class="hljs-string">"language"</span>:<span class="hljs-string">"en"</span>,<span class="hljs-string">"default"</span>:<span class="hljs-string">"en-Latn-US"</span>,<span class="hljs-string">"scrip
ts"</span>:{<span class="hljs-string">"Latn"</span>:{<span class="hljs-string">"strings"</span>:<span class="hljs-string">"E\tAdlam\tAfaka\tCaucasian Albanian\tAhom\tArabic\tImper
ial Aramaic\tArmenian\tAvestan\tBalinese\tBamum\tBassa Vah\tBatak\tBangla\tBhaik
suki\tBlissymbols\tBopomofo\tBrahmi\tBraille\tBuginese\tBuhid\tChakma\tUnified C
anadian Aboriginal Syllabics\tCarian\tCham\tCherokee\tCirth\tCoptic\tCypriot\tCy
rillic\tOld Church Slavonic Cyrillic\tDevanagari\tDeseret\tDuployan shorthand\tE
gyptian demotic\tEgyptian hieratic\tEgyptian hieroglyphs\tElbasan\tEthiopic\tGeo
rgian Khutsuri\tGeorgian\tGlagolitic\tMasaram Gondi\tGothic\tGrantha\tGreek\tGuj
arati\tGurmukhi\tHan with Bopomofo\tHangul\tHan\tHanunoo\tSimplified\tTraditiona
l\tHatran\tHebrew\tHiragana\tAnatolian Hieroglyphs\tPahawh Hmong\tJapanese sylla
.. snip ..
</span></code></pre>
<h3><a class="anchor" aria-hidden="true" id="6-create-a-typesafe-hierarchy-that-mirrors-our-schema"></a><a href="#6-create-a-typesafe-hierarchy-that-mirrors-our-schema" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6. Create a typesafe hierarchy that mirrors our schema</h3>
<p>Our DSL is used to build a singleton accessor object, and we add type information that mirrors its structure, providing a sound interface for accessing fields at runtime.</p>
<p>Our DSL example looks like this:</p>
<pre><code class="hljs css language-typescript">formatWidths = keyindex([<span class="hljs-string">'short'</span>,<span class="hljs-string">'medium'</span>,<span class="hljs-string">'long'</span>,<span class="hljs-string">'full'</span>]);

scope(<span class="hljs-string">'Gregorian'</span>, [
  vector1(<span class="hljs-string">'dateFormats'</span>, formatWidths),
  vector1(<span class="hljs-string">'timeFormats'</span>, formatWidths),
]);
</code></pre>
<p>We use this to dynamically generate the singleton accessor object at library initialization time:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> schema = {
  Gregorian: {
    dateFormats: <span class="hljs-keyword">new</span> Vector1Arrow&lt;FormatWidthType&gt;(<span class="hljs-number">0</span>, formatWidths),
    timeFormats: <span class="hljs-keyword">new</span> Vector1Arrow&lt;FormatWidthType&gt;(<span class="hljs-number">4</span>, formatWidths),
    ..
  },
  Numbers: {
    ..
  }
}
</code></pre>
<p>Then we define a set of types that mirrors the structure of the accessor object. Note that, while it would be possible to generate some of these interfaces directly from the DSL, the types are currently hand-written.</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> FormatWidthType = <span class="hljs-string">'short'</span> | <span class="hljs-string">'medium'</span> | <span class="hljs-string">'long'</span> | <span class="hljs-string">'full'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> CalendarSchema {
  readonly dateFormats: Vector1Arrow&lt;FormatWidthType&gt;;
  readonly timeFormats: Vector1Arrow&lt;FormatWidthType&gt;;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> GregorianSchema <span class="hljs-keyword">extends</span> CalendarSchema {}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Schema {
  readonly Gregorian: GregorianSchema;
}
</code></pre>
<p>Now we can fetch fields from any bundle in a typesafe way:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> value = schema.Gregorian.dateFormats.get(bundle, <span class="hljs-string">'medium'</span>);
<span class="hljs-built_in">console</span>.log(value);
</code></pre>
<pre class="output">
d MMM y
</pre>
<p>A typo will fail to compile ..</p>
<pre><code class="hljs css language-typescript">schema.Gregorian.dateformat.get(bundle, <span class="hljs-string">'medium'</span>);

<span class="hljs-comment">// [ts] Property 'dateformat' does not exist</span>
<span class="hljs-comment">// on type 'CalendarSchema'. Did you mean 'dateFormats'?</span>

schema.Gregorian.dateFormats.get(bundle, <span class="hljs-string">'mediumfoo'</span>);

<span class="hljs-comment">// [ts] Argument of type '"mediumfoo"' is not assignable</span>
<span class="hljs-comment">// to parameter of type 'FormatWidthType'.</span>
</code></pre>
<p>We can enhance the field accessors with other helper methods. For example, <code>mapping(bundle): object</code> lets us fetch all values for a given field efficiently:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> values = schema.Gregorian.dateFormats.mapping(bundle);
<span class="hljs-built_in">console</span>.log(values);
</code></pre>
<pre class="output">
{
  short: "dd/MM/y",
  medium: "d MMM y",
  long: "d MMMM y",
  full: "EEEE, d MMMM y"
}
</pre>
<p>We can hold references to deep parts of the schema that will be repeatedly used:</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">const</span> { dateFormats } schema.Gregorian;

<span class="hljs-comment">// ..</span>

<span class="hljs-keyword">const</span> value = dateFormats.get(bundle, width);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="summary"></a><a href="#summary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<p>Summarizing the benefits of the resource bundle and schema design:</p>
<ul>
<li class="list">Developers don't need to understand the structure of the CLDR, or perform any manual filtering of the JSON data themselves.</li>
<li class="list">Schema access is in code which is checked by the compiler.</li>
<li class="list">Autocompletion for the entire schema, saving the developer from having to remember the names, arguments, and how the types fit together.</li>
<li class="list">Reduce the chance of errors when accessing fields.</li>
<li class="list">Separate concerns about the schema's design and correctness from its usage.</li>
<li class="list">When we evolve the schema we can easily locate the places inside the library that need to be adapted.</li>
<li class="list">We could add comment headers to all of the schema's types and generate documentation, assisting developers in better understanding their meaning and provide examples.</li>
<li class="list">The singleton accessor object is initialized once and reused across all locales.</li>
<li class="list">Bundles are 100 times smaller than the raw JSON form with schema intact (139 MB vs 1.5 MB), and 20 times smaller when storing the values only (34 MB vs 1.5 MB), by reducing the duplication between locales in the same language.</li>
<li class="list">Field lookups become indexes into a single array.</li>
<li class="list">Avoids excessive string concatenation to form paths and construct lookup keys.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/cldr-engine/docs/en/1.1.2/doc-messageformatting-custom"><span class="arrow-prev">← </span><span>Customization</span></a><a class="docs-next button" href="/cldr-engine/docs/en/1.1.2/doc-design-caching"><span>Caching</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#cldr-json-data">CLDR JSON data</a><ul class="toc-headings"><li><a href="#data-size">Data size</a></li><li><a href="#schema-overhead">Schema overhead</a></li><li><a href="#accessing-field-values-can-be-brittle">Accessing field values can be brittle</a></li><li><a href="#questions-so-far">Questions so far:</a></li></ul></li><li><a href="#designing-the-resource-bundle">Designing the resource bundle</a><ul class="toc-headings"><li><a href="#1-flatten-the-schema">1. Flatten the schema</a></li><li><a href="#2-define-an-ordered-traversal-of-all-fields-in-the-schema">2. Define an ordered traversal of all fields in the schema</a></li><li><a href="#3-use-the-dsl-program-to-both-encode-and-access-field-values">3. Use the DSL program to both encode and access field values</a></li><li><a href="#4-encode-all-locales-for-a-given-language-in-single-bundle">4. Encode all locales for a given language in single bundle</a></li><li><a href="#5-define-a-base-region-in-the-bundle-per-script-from-which-all-other-regions-inherit">5. Define a base region in the bundle, per script, from which all other regions inherit</a></li><li><a href="#6-create-a-typesafe-hierarchy-that-mirrors-our-schema">6. Create a typesafe hierarchy that mirrors our schema</a></li></ul></li><li><a href="#summary">Summary</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/cldr-engine/" class="nav-home"><img src="/cldr-engine/img/cldr-engine-logo-w.svg" alt="@phensley/cldr" width="66" height="58"/></a><div><h5>Docs</h5><a href="/cldr-engine/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/cldr-engine/docs/en/doc2.html">Guides (or other categories)</a><a href="/cldr-engine/docs/en/doc3.html">API Reference (or other categories)</a></div><div></div><div><h5>More</h5><a href="https://github.com/phensley/cldr-engine">GitHub</a><a class="github-button" href="https://github.com/phensley/cldr-engine" data-icon="octicon-star" data-count-href="/phensley/cldr-engine/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2020 Patrick Hensley</section></footer></div></body></html>