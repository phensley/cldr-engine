import { format, Options } from 'prettier';

export const HEADER = `\
//
// WARNING: this file was auto-generated by @phensley/cldr-compiler. DO NOT EDIT.
//

`;

export const NOLINT = '// eslint-disable-next-line max-len\n';
export const NOLINT_MAXLINE = '/* eslint-disable max-len */\n';

const FORMAT_OPTIONS: Options = {
  parser: 'typescript',
  printWidth: 100,
  singleQuote: true,
  trailingComma: 'none',
};

export class Code {
  private constructor(readonly path: string[], readonly source: string) {}

  static core(path: string[], source: string): Code {
    return new Code(['packages', 'cldr-core', 'src', ...path], source);
  }

  static languagetag(path: string[], source: string): Code {
    return new Code(['packages', 'language-tag', 'src', ...path], source);
  }

  static locale(path: string[], source: string): Code {
    return new Code(['packages', 'locale', 'src', ...path], source);
  }

  static localematcher(path: string[], source: string): Code {
    return new Code(['packages', 'locale-matcher', 'src', ...path], source);
  }

  static plurals(path: string[], source: string): Code {
    return new Code(['packages', 'plurals', 'src', ...path], source);
  }

  static rbnf(path: string[], source: string): Code {
    return new Code(['packages', 'cldr-ext-rbnf', 'src', ...path], source);
  }

  static types(path: string[], source: string): Code {
    return new Code(['packages', 'cldr-types', 'src', ...path], source);
  }

  static top(path: string[], source: string): Code {
    return new Code(path, source);
  }
}

const ENUM_UNSAFE = /[^a-z\d\/_-]+/gi;
const DASH = /[\/-]+/g;

export const enumName = (raw: string) => raw.replace(ENUM_UNSAFE, '').replace(DASH, '_');

const FIELD_SUFFIX = /.+(-alt-(variant|short)|-yeartype-leap)$/g;

export const stripFieldSuffix = (raw: string) => {
  return raw.replace(FIELD_SUFFIX, '');
};

export const formatSource = (raw: string) => format(raw, FORMAT_OPTIONS);

export const lineWrap = (max: number, sep: string, values: string[]): string => {
  let res = '';
  let width = 0;
  max -= 2;
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (width + value.length + 2 > max) {
      res += '\n';
      width = 0;
    }
    if (i > 0) {
      res += `${sep} `;
    } else {
      res += '  ';
    }
    width += 2;
    res += value;
    width += value.length;
  }
  return res;
};

export const objectToString = (o: any): string =>
  Object.keys(o)
    .map((k) => [k, o[k]].join(':'))
    .join('|');

/**
 * Return a sorted array holding the set's elements.
 */
export const sortSet = (set: Set<string>): string[] => {
  const res: string[] = [];
  set.forEach((v) => res.push(v));
  return res.sort();
};

/**
 * Repeat the string N times.
 */
export const repeat = (s: string, n: number) => {
  let r = '';
  for (let i = 0; i < n; i++) {
    r += s;
  }
  return r;
};

/**
 * Pad the string to the given width.
 */
export const pad = (width: number, str: string) => {
  const delta = width - str.length;
  return delta > 0 ? repeat(' ', delta) : '';
};

const hexchars = '0123456789abcdef';

/**
 * Convert a number N to a hex string containing exactly D digits, inserting
 * leading '0' digits as needed.
 */
const escapeHex = (n: number, d: number) => {
  let r = '';
  let i = 0;
  while (i < d) {
    const x = n % 16;
    r = hexchars[x] + r;
    n -= x;
    n /= 16;
    i++;
  }
  return r;
};

const inRange = (s: number, e: number) => (n: number) => n >= s && n <= e;

const isLatin1Invisible = (c: number) => c === 0xa0 || c === 0xad;
const isControl0 = inRange(0, 0x1f);
const isControl1 = inRange(0x80, 0x9f);

const invisibles = {
  '\\': '\\\\',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\v': '\\v',
};

/**
 * Escape a string so it can appear as a literal in Typescript source.
 */
export const escapeString = (raw: string, delim: string = "'") => {
  let esc = delim;
  const len = raw.length;
  for (let i = 0; i < len; i++) {
    const ch = raw[i];
    switch (ch) {
      case '"':
      case "'":
      case '`':
        esc += ch === delim ? '\\' + ch : ch;
        break;

      case '\\':
      case '\b':
      case '\f':
      case '\n':
      case '\r':
      case '\t':
      case '\v':
        esc += invisibles[ch];
        break;

      default: {
        // Check range and escape hex.
        const code = raw.charCodeAt(i);
        if (isControl0(code) || isControl1(code) || isLatin1Invisible(code)) {
          esc += `\\x${escapeHex(code, 2)}`;
        } else if (code > 0xff) {
          esc += `\\u${escapeHex(code, 4)}`;
        } else {
          esc += ch;
        }
      }
    }
  }
  return esc + delim;
};
